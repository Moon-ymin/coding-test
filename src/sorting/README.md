## 선택 정렬
- 무작위 데이터에서 `가장 작은 데이터`를 선택해 맨 앞의 데이터와 바꾸는 과정
- 시간 복잡도 : O(N^2)

## 삽입 정렬
- 처리되지 않는 데이터를 하나씩 골라 적절한 위치에 삽입
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적이다
- 정렬이 이루어진 후 오름차순을 유지한다는 특징
- 시간 복잡도 : O(N^2), 거의 정렬되어 있을 경우 O(N)

## 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)으로 설정
  1) pivot 값 보다 큰 데이터를 왼쪽에서 부터 찾고, pivot 값보다 작은 데이터를 오른쪽에서부터 찾는다
  2) 작은 데이터와 큰 데이터의 위치를 서로 변경한다
  3) 큰 데이터와 작은 데이터의 위치가 엇갈리는 경우 pivot과 작은 데이터의 위치를 서로 변경한다
  ⇒ pivot을 기준으로 데이터 묶음을 나누는 작업을 `분할` 혹은 `파티션`이라고 한다
- 시간 복잡도 : 평균 - O(NlogN), 최악 - O(N^2)

## 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘
- 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용가능
- 데이터의 개수가 N, 데이터(양수) 중 최대값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장
- 진행 순서
  1) 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있는 리스트 생성
  2) 데이터를 하나씩 확인하며 데이터 값과 동일한 인덱스의 데이터를 1씩 증가
  3) 결과적으로 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록된다
  4) 결과를 확인할 때는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스 출력
- 복잡도
  - 시간 복잡도, 공간 복잡도 모두 O(N+K)
  - 동일한 값을 가지는 데이터가 여러 개 등장할 떄 효과적 (ex. 성적의 경우 같은 점수 학생 여러 명)